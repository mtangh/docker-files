# docker-dockerfile

# Dockerfile get
dockerfile-get-path() {
  local _buildpath="${1:-}"; shift
  if [ -z "${_buildpath}" ]
  then
    _buildpath="$(pwd)/Dockerfile" || :
  else
    _buildpath=( $(echo "${_buildpath}") )
    _buildpath="${_buildpath[0]}"
  fi
  [ -d "${_buildpath}" ] &&
  _buildpath="${_buildpath}/Dockerfile" || :
  [ "${_buildpath}" = "${_buildpath##*/}" ] &&
  _buildpath="$(pwd)/${_buildpath}" || :
  [ -d "${_buildpath%/*}" ] &&
  _buildpath=$(cd "${_buildpath%/*}" 2>/dev/null; pwd)"/${_buildpath##*/}" || :
  [ -n "${_buildpath}" ] &&
  [ -f "${_buildpath:-X}" -a -r "${_buildpath:-X}" ] &&
  echo "${_buildpath}"
  return $?
}

dockerfile-cat() {
  local _buildpath=""
  local _line_data=""
  [ $# -gt 0  ] &&
  _buildpath=$(dockerfile-get-path "${1:-}") &&
  shift || :
  if [ -n "${_buildpath}" ]
  then cat "${_buildpath}"
  else cat
  fi |
  while IFS= read _line_data
  do
    case "${_line_data}" in
    *\\) print "%s" "${_line_data%\\}";;
    *)   echo "${_line_data}" ;;
    esac
  done
  return $?
}

dockerfile-cat-FROM() {
  dockerfile-cat "$@" |
  egrep -i '^[[:space:]]*(FROM|#@&)[[:space:]]+' |
  ${SED} -re 's/^[[:space:]]*((FROM[^#]+|#@&.+)[^[:space:]])([[:space:]]*#.*$|$)/\1/gi' |
  ${AWK} -f <( : && {
cat - <<-'_EOF_'
BEGIN{ sn="-"; ti=""; pl="-"; an=""; };
$0 ~ /^#@&/ {
  an = gensub(/^#@&[[:space:]]+([^[:space:]]+).+$/,"\\1",1,$0);
}
toupper($0) - /^FROM/ {
  if( match(toupper($0),/[[:space:]]+AS[[:space:]]+/) ) {
    ti = gensub(/^.+[[:space:]]+([^[:space:]]+)[[:space:]]+[Aa][Ss][[:space:]].+$/,"\\1",1,$0);
    sn = gensub(/^.+[[:space:]]+[Aa][Ss][[:space:]]+([^[:space:]]+)[[:space:]]*$/,"\\1",1,$0);
  } else {
    ti = gensub(/^.+[[:space:]]+([^[:space:]]+)[[:space:]]*$/,"\\1",1,$0);
  }
};
tolower($0) ~ /--platform=/ {
  pl = gensub(/^.+--platform=([^[:space:]]*).*$/,"\\1",1,$0);
};
sn != "" && ti != "" {
  print(NR-1,sn,ti,pl,an);
  sn="";ti="-";pl="-";an="";
};
_EOF_
  }; )
  return $?
}

# number of stage
dockerfile-num-of-stage() {
  local _buildpath=$(dockerfile-get-path "${1:-}"); shift
  local _stage_num=$(dockerfile-cat-FROM "${_buildpath}"|wc -l 2>/dev/null)
  echo ${_stage_num:-0}
  return 0
}

# multi-stage dockerfile
dockerfile-multi-stage() {
  local _stage_num=$(dockerfile-num-of-stage "${1:-}" 2>/dev/null)
  [ ${_stage_num:-0} -gt 1 ]
  return $?
}

# multi-stage chooser
dockerfile-stage-chooser() {
  local _buildpath=$(dockerfile-get-path "${1:-}"); shift
  dockerfile-multi-stage "${_buildpath}" 1>/dev/null 2>&1 && {
    echo "Choose a stage to run."
    echo
    dockerfile-stage-list -F "${_buildpath}" 2>/dev/null
    echo
    return 1
  } || :
  return 0
}

# list stage
dockerfile-stage-list() {
  local _buildpath=""
  local _formatted=0
  local _withimage=0
  local _imagepath=""
  local _cimagetmp=""
  local _multi_stg=0
  local _stage_ind=0
  local _stagename=""
  local _in_record=""
  local _prtheader="IDX As From ARCH Image"
  local _prtformat="%s %s %s %s %s"
  eval $(getoptions "F|format=_formatted I|image=_withimage" "$@")
  while getoptions_has_next
  do
    eval $(getoptions_shift)
    case "${_getopt_V:=}" in
    -*)
cat <<_EOD_ 1>&2
Usage: ${FUNCNAME} [-IF] [/path/to/Dockerfile]
_EOD_
      return 2
      ;;
    *)
      [ -z "${_buildpath}" ] && {
        _buildpath="${_getopt_V}"
      } || :
      ;;
    esac
  done
  eval $(getoptions_end)
  _buildpath=$(dockerfile-get-path "${_buildpath}") ||
    return 1
  __dockerfile_attributes_is_exported ||
    eval $(dockerfile-env-export "${_buildpath}") || :
  _imagepath=$(
    dockerfile-env_IMAGEPATH "${_buildpath}" ||
    dockerfile-imagepath-from-dir "${_buildpath}" ||
    :; )
  dockerfile-multi-stage "${_buildpath}" &&
    _multi_stg=1 || :
  if [ ${_formatted} -ne 0 ]
  then
    _prtformat=$( : && {
      eval $(dockerfile-build-opts-apply "${_buildpath}")
      while read _in_record
      do
        _cw2=$( echo "${_in_record}" |
                __adjustcolwidth "${_cw2:-12}" 2 )
        _cw3=$( echo "${_in_record}" |
                __adjustcolwidth "${_cw3:-12}" 3 )
        _cw4=$( echo "${_in_record}" |
                __adjustcolwidth "${_cw4:-12}" 4 )
      done < <(dockerfile-cat-FROM "${_buildpath}")
      printf "%s" "%3s %-${_cw2}s%-${_cw3}s%-${_cw4}s%s"
    }; )
  fi
  ( : && {
    [ ${_formatted} -ne 0 ] &&
    echo ${_prtheader} || :
    eval $(dockerfile-build-opts-apply "${_buildpath}")
    while read _in_record
    do
      _cimagetmp=""
      _stage_ind=""
      _stagename=""
      eval $(
        echo "${_in_record}" |${AWK} \
        '{printf("_stage_ind=%s;_stagename=%s;_cimagetmp=%s;",$1,$2,$5);}' \
        2>/dev/null; )
      _cimagetmp="${_cimagetmp//-}"
      _stagename="${_stagename//-}"
      [ ${_multi_stg:-0} -ne 0 ] ||
      _stage_ind="-" 
      if [ -n "${_imagepath}" -a -z "${_cimagetmp:-}" ]
      then
        _cimagetmp=$(
          dockerfile-imagepath-echo \
          "${_imagepath}" "${_stage_ind}" "${_stagename}" \
          2>/dev/null; )
      else :
      fi
      eval echo $(echo ${_in_record}${_cimagetmp:+ ${_cimagetmp}})
    done < <(dockerfile-cat-FROM "${_buildpath}")
  }; )|
  ${AWK} -vPfmt="${_prtformat}" \
  '{print( sprintf(Pfmt,$1,$2,$3,$4,$5) );}' 2>/dev/null
  return $?
}

# Apply build-args
dockerfile-build-opts-apply() {
  local _buildpath="${1:-}"; shift
  local _buildopts=""
  _buildpath=$(dockerfile-get-path "${_buildpath}") && {
    cat "${_buildpath}" |dockerfile-cat |${SED} -nre \
    's/^[[:space:]]*ARG[[:space:]]+([^=]+=.*)$/\1;/gip'
    dockerfile-env_BUILDOPTS "${_buildpath}" |${SED} -nre \
    's/([^=]+[[:space:]])([_0-9A-Za-z]+=([^[:space:]]+|'"'[^']+'|''"'|""))/\2;/gp'
  } 2>/dev/null
  return $?
}

# Unset build-args
dockerfile-build-opts-unset() {
  local _buildpath="${1:-}"; shift
  local _buildopts=""
  _buildpath=$(dockerfile-get-path "${_buildpath}") && {
    cat "${_buildpath}" |dockerfile-cat |${SED} -nre \
    's/^[[:space:]]*ARG[[:space:]]+([^=]+)=.*$/unset \1;/gip'
    dockerfile-env_BUILDOPTS "${_buildpath}" |${SED} -re \
    's/([^=]+[[:space:]])([_0-9A-Za-z]+)=([^[:space:]]+|'"'[^']+'|''"'|"")/unset \2;/g'
  } 2>/dev/null
  return $?
}

# Get ARG
dockerfile-get-ARG() {
  local _c_arg_key="${1:-}"; shift
  local _buildpath="${1:-}"; shift
  _buildpath=$(dockerfile-get-path "${_buildpath}") && {
    cat "${_buildpath}" |dockerfile-cat |${SED} -nre \
    's/^[[:space:]]*ARG[[:space:]]+([^=]+)[[:space:]]*=[[:space:]]*(([^=].*)$|$)/\1=\3/gip' |
    if [ -n "${_c_arg_key}" -a "${_c_arg_key}" != "-" ]
    then egrep '^'"${_c_arg_key}="
    else cat
    fi
  } 2>/dev/null
  return $?
}

# Has a ARG
dockerfile-has-ARG() {
  local _c_arg_key="${1:-}"; shift
  local _buildpath="${1:-}"; shift
  _buildpath=$(dockerfile-get-path "${_buildpath}") &&
  [ -n "${_c_arg_key}" ] && {
    cat "${_buildpath}" |dockerfile-cat |egrep \
    '^[[:space:]]*ARG[[:space:]]+('"${_c_arg_key}"')([[:space:]]*=[[:space:]]*([^=].*)$|$)'
  } 1>/dev/null 2>&1
  return $?
}

# Get stage name
dockerfile-stage-get() {
  local _indorname="${1:-}"; shift
  local _stage_key="${1:-}"; shift
  local _buildpath="${1:-}"; shift
  _buildpath=$(dockerfile-get-path "${_buildpath}") ||
    return 1
  case "${_indorname}" in
  ind|index)
    _indorname='{print($1);}'
    ;;
  name)
    _indorname='{print($2);}'
    ;;
  from)
    _indorname='{print($3);}'
    ;;
  platform|arch)
    _indorname='{print($4);}'
    ;;
  tag|image)
    _indorname='{print($5);}'
    ;;
  *)
    return 2
    ;;
  esac
  [ -n "${_stage_key}" ] && {
    case "${_stage_key}" in
    +[0-9]*)
      _stage_key="${_stage_key#*+}"
      ;;
    @[0-9A-Za-z]*)
      _stage_key="${_stage_key#*@}"
      ;;
    esac
    dockerfile-stage-list -I "${_buildpath}" |
    ${AWK} '$1=="'"${_stage_key}"'" || $2=="'"${_stage_key}"'" '"${_indorname};"
  }
  return $?
}

# Get index of stage
dockerfile-stage-get-index() {
  dockerfile-stage-get index "$@"
  return $?
}

# Get name of stage
dockerfile-stage-get-name() {
  dockerfile-stage-get name "$@"
  return $?
}

# Get "from" of stage
dockerfile-stage-get-from() {
  dockerfile-stage-get from "$@"
  return $?
}

# Get platform of stage
dockerfile-stage-get-platform() {
  dockerfile-stage-get platform "$@"
  return $?
}

# Get repo-tag of stage
dockerfile-stage-get-tag() {
  dockerfile-stage-get tag "$@"
  return $?
}

# Exists stage index
dockerfile-stage-has-index() {
  local _stage_ind=$(dockerfile-stage-get index "$@") || :
  [ -n "${_stage_ind}" ]
  return $?
}

# Exists stage name
dockerfile-stage-has-name() {
  local _stagename=$(dockerfile-stage-get name "$@") || :
  [ -n "${_stagename##*-}" ]
  return $?
}

# Get stage name by index
dockerfile-imagepath-get() {
  local _buildpath=""
  local _stage_key=""
  local _imagepath=""
  local _stage_ind=""
  local _stagename=""
  local _multi_stg=0
  while [ $# -gt 0 ]
  do
    [ -z "${1:-}" ] ||
    case "${1:-}" in
    -)
      ;;
    --)
      ;;
    +[0-9]*|@[0-9A-Za-z]*)
      _stage_key="${1:-}"
      ;;
    *)
      if [ -z "${_buildpath:-}" ]
      then _buildpath="${1:-}"
      else :
      fi;
    esac
    shift
  done
  _buildpath=$(dockerfile-get-path "${_buildpath}") ||
    return 1
  __dockerfile_attributes_is_exported ||
    eval $(dockerfile-env-export "${_buildpath}")
  [ -z "${_imagepath}" ] &&
    _imagepath=$(dockerfile-env_IMAGEPATH "${_buildpath}") || :
  [ -z "${_imagepath}" ] &&
    _imagepath=$(dockerfile-imagepath-from-dir "${_buildpath}") || :
  [ -z "${_imagepath}" ] &&
    return 1 || :
  dockerfile-multi-stage "${_buildpath}" 1>/dev/null 2>&1 &&
    _multi_stg=1 || :
  [ ${_multi_stg} -eq 0 ] &&
    _stage_key="-" || :
  case "${_stage_key}" in
  +[0-9]*)
    _stage_ind="${_stage_key#*+}"
    dockerfile-stage-has-index "${_stage_ind}" "${_buildpath}" 1>/dev/null 2>&1 && {
      _stagename=$(
        dockerfile-stage-get-name "${_stage_ind}" "${_buildpath}" 2>/dev/null)
    } ||
	  return 2
    ;;
  @[0-9A-Za-z]*)
    _stagename="${_stage_key#*@}"
    _stage_ind=$(
      dockerfile-stage-get-index "${_stagename}" "${_buildpath}" 2>/dev/null)
    [ $? -eq 0 -a -n "${_stage_ind}" ] ||
      return 2
    ;;
  *)
    _stage_ind=""
    _stagename=""
    ;;
  esac
  [ ${_multi_stg} -ne 0 ] &&
  if [ -z "${_stage_ind}${_stagename}" ]
  then
    _stage_key=$(
      dockerfile-stage-list "${_buildpath}" |tail -n +2 |
      ${AWK} '{print($1);}' 2>/dev/null)
  else
    _stage_key="${_stage_ind}"
  fi || :
  [ -n "${_stage_key}" ] &&
  for _stage_ind in ${_stage_key}
  do
    _stagename=$(dockerfile-stage-get-name "${_stage_ind}" "${_buildpath}" 2>/dev/null)
    dockerfile-imagepath-echo "${_imagepath}" "${_stage_ind}" "${_stagename}"
  done
  return $?
}

dockerfile-imagepath-from-dir() {
  local _buildpath=$(dockerfile-get-path "${1:-}" 2>/dev/null); shift
  local _build_dir=""
  local _imagepath=""
  local _imagepart=""
  local _imagerepo=""
  local _image_tag=""
  if [[ "${_buildpath}" =~ ^http(s:|:)//[^/]+/(.+)$ ]]
  then _build_dir="${BASH_REMATCH[2]%/*}"
  elif [[ "${_buildpath}" =~ ^(${DOCKERFILES_ROOT_DIR})/(.+)$ ]]
  then _build_dir="${BASH_REMATCH[2]%/*}"
  else return 2
  fi &&
  [ -n "${_build_dir:-}" ] &&
  for _imagepart in $(echo ${_build_dir//\// })
  do
    [[ "${_imagepart}" =~ ^_.*_$ ]] || {
      _imagerepo="${_imagerepo:+${_imagerepo}-}${_imagepart}"
    } || :
  done &&
  [ -n "${_imagerepo:-}" ] && {
    _imagerepo="${_imagerepo//[/+#%&@]/-}"
    _imagerepo="${_imagerepo//[.:=]/_}"
    _imagerepo="${_imagerepo// }"
    _image_tag="${_image_tag//[/+#%&@]/-}"
    _image_tag="${_image_tag//[.:=]/_}"
    _image_tag="${_image_tag// }"
  } &&
  [ -n "${_imagerepo:-}" ] && {
    echo "${_imagerepo}${_image_tag:+:${_image_tag}}"
  }
  return $?
}

dockerfile-imagepath-echo() {
  local _imagepath="${1:-}"; shift
  local _stage_ind="${1:-}"; shift
  local _stagename="${1:-}"; shift
  [ -n "${_imagepath}" -a \
    -n "${_stage_ind}${_stagename}" ] && {
    _stage_ind="${_stage_ind##-}"
    _stagename="${_stagename##-}"
    _stagename="${_stagename:=${_stage_ind}}"
    case "${_imagepath}" in
    [-_0-9A-Za-z]*:[-_0-9A-Za-z]*)
      if [ -n "${_stagename}" ]
      then echo "${_imagepath}${_stagename:+_${_stagename}}"
      else echo "${_imagepath}"
      fi
      ;;
    [-_0-9A-Za-z]*)
      if [ -n "${_stagename}" ]
      then echo "${_imagepath}${_stagename:+:${_stagename}}"
      else echo "${_imagepath}"
      fi
      ;;
    *)
      ;;
    esac
  }
  return $?
}

# docker attributes get
dockerfile-attributes-get() {
  local _buildpath=""
  local _exportflg=0
  local _dvariable=""
  eval $(getoptions "E|export=_exportflg" "$@")
  while getoptions_has_next
  do
    eval $(getoptions_shift)
    case "${_getopt_V:=}" in
    -*)
      echo "${FUNCNAME}: ERROR: Illegal options '${_getopt_V}'". 1>&2
      return 2
      ;;
    *)
      [ -z "${_buildpath}" ] && {
        _buildpath="${_getopt_V}"
      } || :
      ;;
    esac
  done
  eval $(getoptions_end)
  _buildpath=$(dockerfile-get-path "${_buildpath}") ||
    return 1
  [ ${_exportflg} -ne 0 ] && printf "export " || :
  echo "$(__dockerfile_attributes_set_exported);"
  cat "${_buildpath}" |egrep '^#@[[:space:]]*' |${SED} -ne \
  's;^#@[[:space:]]*\([_A-Za-z][_0-9A-Za-z]*\)[[:space:]]*=[[:space:]]*\([^[:space:]]*.*\)[[:space:]]*$;\1=\2;gp' |
  while read _dvariable
  do
    [ -n "${_dvariable}" ] ||
    continue
    [ ${_exportflg} -ne 0 ] &&
    echo "export ${_dvariable};" ||
    echo "${_dvariable};"
  done
  return $?
}

# dockerfile export env
dockerfile-env-export() {
  dockerfile-attributes-get -E "$@"
  return $?
}

__dockerfile_attributes_key() {
  echo "__dockerfile_attributes_exported"
  return 0
}

__dockerfile_attributes_set_exported() {
  echo "$(__dockerfile_attributes_key)=1"
  return 0
}

__dockerfile_attributes_is_exported() {
  eval '[ ${'$(__dockerfile_attributes_key)':-0} -ne 0 ]'
  return $?
}

# dockerfile get env
dockerfile-env-get() {
  local _cattr_key="${1:-}"; shift
  local _buildpath="${1:-}"; shift
  local _cattr_val=""
  local _cakey_tmp=""
  [ -n "${_cattr_key}" ] ||
    return 2
  _buildpath=$(dockerfile-get-path "${_buildpath}") ||
    return 1
  case "${_cattr_key}" in
  DOCKER_*)
    ;;
  *)
    _cattr_key="DOCKER_${_cattr_key}"
    ;;
  esac
  __dockerfile_attributes_is_exported ||
    eval $(dockerfile-env-export "${_buildpath}")
  for _cakey_tmp in "${_cattr_key}" "${_cattr_key#DOCKER_}"
  do
    _cattr_val=$(eval 'echo ${'"${_cakey_tmp}"':-}')
    [ -n "${_cattr_val}" ] && break || :
  done
  [ -n "${_cattr_val}" ] &&
  echo "${_cattr_val}"
  return $?
}

dockerfile-env_IMAGEPATH() {
  local _imgname=$(dockerfile-env-get DOCKER_IMAGEPATH "$@")
  local _imgrepo=$(echo "${_imgname}" |${AWK} -F: '{print($1);}')
  local _img_tag=$(echo "${_imgname}" |${AWK} -F: '{print($2);}')
  [ -n "${_imgrepo}${_img_tag}" ] &&
  echo "${_imgrepo}${_img_tag:+:${_img_tag}}"
  return $?
}

dockerfile-env_IMAGEREPO() {
  dockerfile-env_IMAGEPATH "$@" |
  ${AWK} -F: '{print($1);}' 2>/dev/null
  return $?
}

dockerfile-env_IMAGE_TAG() {
  dockerfile-env_IMAGEPATH "$@" |
  ${AWK} -F: '{print($2);}' 2>/dev/null
  return $?
}

dockerfile-env_IMAGE_VER() {
  dockerfile-env-get DOCKER_IMAGE_VER "$@"
  return $?
}

dockerfile-env_CONTAINER() {
  dockerfile-env-get DOCKER_CONTAINER "$@"
  return $?
}

dockerfile-env_LATEST_IS() {
  dockerfile-env-get DOCKER_LATEST_IS "$@"
  return $?
}

dockerfile-env_BUILDOPTS() {
  __load_external_env "${1:-}" "BUILDOPTS" "build"
  return $?
}

dockerfile-env_BOOT_OPTS() {
  __load_external_env "${1:-}" "BOOT_OPTS" "run"
  return $?
}

dockerfile-env_EXEC_OPTS() {
  __load_external_env "${1:-}" "EXEC_OPTS" "exec"
  return $?
}

dockerfile-env_PUBLISHED() {
  __load_external_env "${1:-}" "PUBLISHED" "published"
  return $?
}

__load_external_env() {
  local _buildpath="${1:-}"; shift
  local _opts_name="${1:-}"; shift
  local _opts_suff="${1:-}"; shift
  local _file_suff=""
  local _opt_value=""
  local _eval_expr=""
  local _tmp_value=""
  _buildpath=$(dockerfile-get-path "${_buildpath}") ||
    return 1
  __dockerfile_attributes_is_exported ||
    eval $(dockerfile-env-export "${_buildpath}") || :
  [ -n "${_opts_name}" ] && {
    _opt_value=$(dockerfile-env-get "${_opts_name}" "${_buildpath}")
  } || :
  for _file_suff in \
  "${_opts_name}" \
  "${_opts_name:+opts.${_opts_name}}" "${_opts_suff:+opts.${_opts_suff}}"
  do
    [ -n "${_file_suff}" -a \
      -f "${_buildpath}.${_file_suff}" -a \
      -r "${_buildpath}.${_file_suff}" ] && {
      _tmp_value=$(echo $(cat "${_buildpath}.${_file_suff}" 2>/dev/null))
      [ -n "${_tmp_value}" ] &&
      _opt_value="${_opt_value:+${_opt_value} }${_tmp_value}"
    } || :
  done
  [ -n "${_opts_name}" -a \
    -f "${_buildpath}.opts" -a \
    -r "${_buildpath}.opts" ] && {
    _eval_expr='. "'"${_buildpath}"'.opts" 2>/dev/null && '
    _eval_expr="${_eval_expr}"'echo "${DOCKER_'"${_opts_name}"':-}";'
    _tmp_value=$(eval ${_eval_expr})
    [ -n "${_tmp_value}" ] &&
    _opt_value="${_opt_value:+${_opt_value} }${_tmp_value}"
  } || :
  [ -n "${_opt_value}" ] &&
  echo "${_opt_value}"
  return $?
}

# vim: set ff=unix ts=2 sw=2 sts=2 et : This line is VIM modeline
