# docker-dockerfile

# Docker file get
dockerfile-get-path() {
  local _buildpath="${1:-}"; shift
  [ -z "${_buildpath}" ] &&
   _buildpath="$(pwd)/Dockerfile" || :
  [ -d "${_buildpath}" ] &&
   _buildpath="${_buildpath}/Dockerfile" || :
  [ "${_buildpath}" = "${_buildpath##*/}" ] &&
   _buildpath="$(pwd)/${_buildpath}" || :
  [ -n "${_buildpath}" ] && echo "${_buildpath}"
  return $?
}

# number of stage
dockerfile-num-of-stage() {
  local _buildpath=$(dockerfile-get-path "${1:-}" 2>/dev/null); shift
  local _stage_num=$(dockerfile-stage-list "${_buildpath}"|wc -l 2>/dev/null)
  echo ${_stage_num:-0}
  return 0
}

# multi-stage dockerfile
dockerfile-multi-stage() {
  local _stage_num=$(dockerfile-num-of-stage "${1:-}" 2>/dev/null)
  [ ${_stage_num:-0} -gt 1 ]
  return $?
}

# list stage
dockerfile-stage-list() {
  local _buildpath=""
  local _formatted=0
  eval $(getoptions "f|format=_formatted" "$@")
  while getoptions_has_next
  do
    eval $(getoptions_shift)
    case "${_getopt_V:=}" in
    -*)
      echo "${FUNCNAME}: ERROR: Illegal options '${_getopt_V}'". 1>&2
      return 2
      ;;
    *)
      [ -z "${_buildpath}" ] && {
        _buildpath="${_getopt_V}"
      } || :
      ;;
    esac
  done
  eval $(getoptions_end)
  _buildpath="$(dockerfile-get-path ${_buildpath} 2>/dev/null)"
  [ -f "${_buildpath}" -a -r "${_buildpath}" ] && {
    [ ${_formatted} -eq 0 ] || {
      printf "%3s %-24s%s" "IDX" "From" "As"; echo
    }
    egrep -i '^[[:space:]]*FROM[[:space:]]+' "${_buildpath}" |
    if [ ${_formatted} -eq 0 ]
    then ${AWK} '{print(NR-1,$2,$4);}'
    else ${AWK} '{print(sprintf("%3d %-24s%s",NR-1,$2,$4));}'
    fi 2>/dev/null
  }
  return $?
}

# Get stage name by index
dockerfile-stage-get-name() {
  local _stage_ind="${1:-}"; shift
  local _buildpath=$(dockerfile-get-path "${1:-}" 2>/dev/null); shift
  [ -n "${_stage_ind}" ] && {
    _stage_ind="${_stage_ind##*+}"
    dockerfile-stage-list "${_buildpath}" |
    ${AWK} '$1=="'"${_stage_ind}"'" {print($3);}'
  }
  return $?
}

# Get stage index by name
dockerfile-stage-get-index() {
  local _stagename="${1:-}"; shift
  local _buildpath=$(dockerfile-get-path "${1:-}" 2>/dev/null); shift
  [ -n "${_stagename}" ] && {
    _stagename="${_stagename##*@}"
    dockerfile-stage-list "${_buildpath}" |
    ${AWK} '$3=="'"${_stagename}"'" {print($1);}'
  }
  return $?
}

# Exists stage index
dockerfile-stage-has-index() {
  local _stage_ind="${1:-}"; shift
  local _buildpath=$(dockerfile-get-path "${1:-}" 2>/dev/null); shift
  [ -n "${_stage_ind}" ] && {
    _stage_ind="${_stage_ind##*+}"
    _stage_ind=$(
      dockerfile-stage-list "${_buildpath}" |
      ${AWK} '$1=="'"${_stage_ind}"'" {print($1);}' 2>/dev/null; )
    [ -n "${_stage_ind}" ]
  }
  return $?
}

# Get stage name by index
dockerfile-imagetag-get() {
  local _stage_ind=""
  local _stagename=""
  local _cimagetag=""
  local _stage_key="${1:-}"; shift
  local _buildpath=$(dockerfile-get-path "${1:-}" 2>/dev/null); shift
  local _multi_stg=0
  _cimagetag=$(dockerfile-env-get DOCKER_IMAGE_TAG "${_buildpath}" 2>/dev/null) || {
    return 1
  }
  dockerfile-multi-stage "${_buildpath}" 1>/dev/null 2>&1 && {
    _multi_stg=1
  } || :
  [ ${_multi_stg} -eq 0 ] && {
    [ -n "${_cimagetag}" ] && echo "${_cimagetag}"
    return $?
  } || :
  case "${_stage_key}" in
  +[0-9]*)
    _stage_ind="${_stage_key##*+}"
    dockerfile-stage-has-index "${_stage_ind}" "${_buildpath}" 1>/dev/null 2>&1 && {
      _stagename=$(
        dockerfile-stage-get-name "${_stage_ind}" "${_buildpath}" 2>/dev/null)
    } || return 2
    ;;
  @[0-9A-Za-z]*)
    _stagename="${_stage_key##*@}"
    _stage_ind=$(
      dockerfile-stage-get-index "${_stagename}" "${_buildpath}" 2>/dev/null)
    ;;
  *)
    _stage_ind=""
    _stagename=""
    ;;
  esac
  if [ -z "${_stage_ind}${_stagename}" ]
  then
    _stage_key=$(dockerfile-stage-list "${_buildpath}" |awk '{print($1);}' 2>/dev/null)
  else
    _stage_key="${_stage_ind}"
  fi
  [ -n "${_stage_key}" ] &&
  for _stage_ind in ${_stage_key}
  do
    _stagename=$(dockerfile-stage-get-name "${_stage_ind}" "${_buildpath}" 2>/dev/null)
    case "${_cimagetag}" in
    [0-9A-Za-z]*:*)
      if [ -n "${_stagename}" ]
      then echo "${_cimagetag}${_stagename:+@${_stagename}}"
      else echo "${_cimagetag}${_stage_ind:+#${_stage_ind}}"
      fi
      ;;
    [0-9A-Za-z]*)
      if [ -n "${_stagename}" ]
      then echo "${_cimagetag}${_stagename:+:${_stagename}}"
      else echo "${_cimagetag}${_stage_ind:+:#${_stage_ind}}"
      fi
      ;;
    *)
      ;;
    esac
  done
  return $?
}

# dockerfile get env
dockerfile-env-get() {
  local _cattr_key="${1:-}"; shift
  local _buildpath=$(dockerfile-get-path "${1:-}"); shift
  local _cattr_val=""
  [ -f "${_buildpath}" -a -r "${_buildpath}" ] && {
    if [ -z "${_cattr_key}" ]
    then dockerfile-attributes-get "${_buildpath}"
    else
      _cattr_val=$(eval $(
        dockerfile-attributes-get "${_buildpath}" |
        egrep '^'"${_cattr_key}"'=.*' 2>/dev/null &&
        echo 'echo $'"${_cattr_key}") )
      [ -n "${_cattr_val}" ] && {
        echo "${_cattr_val}"
      }
    fi #2>/dev/null
  }
  return $?
}

# docker attributes get
dockerfile-attributes-get() {
  local _buildpath=""
  local _exportflg=0
  local _dvariable=""
  eval $(getoptions "E|export=_exportflg" "$@")
  while getoptions_has_next
  do
    eval $(getoptions_shift)
    case "${_getopt_V:=}" in
    -*)
      echo "${FUNCNAME}: ERROR: Illegal options '${_getopt_V}'". 1>&2
      return 2
      ;;
    *)
      [ -z "${_buildpath}" ] && {
        _buildpath="${_getopt_V}"
      } || :
      ;;
    esac
  done
  eval $(getoptions_end)
  _buildpath=$(dockerfile-get-path "${_buildpath}")
  [ -r "${_buildpath}" ] && {
    cat "${_buildpath}" |
    ${SED} -ne 's;^#@[ ]*\([_A-Za-z][_0-9A-Za-z]*\)[ ]*=[ ]*\(.*\)[ ]*$;\1=\2;gp' |
    while read _dvariable
    do
      [ -z "${_dvariable}" ] || {
        [ ${_exportflg} -ne 0 ] &&
        echo "export ${_dvariable};" ||
        echo "${_dvariable};"
      }
    done
  } #2>/dev/null
  return $?
}

# vim: set ff=unix ts=2 sw=2 sts=2 et : This line is VIM modeline
